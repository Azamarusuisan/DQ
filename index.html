<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DRAGON QUEST II - HTML EDITION</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        #game-container {
            position: relative;
            width: 512px;
            height: 480px;
            image-rendering: pixelated;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* UI is rendered on Canvas */
    </style>
</head>

<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="256" height="240"></canvas>
        <!-- UI is drawn on Canvas directly -->
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const TILE_SIZE = 16;
        const SCREEN_WIDTH = 256;
        const SCREEN_HEIGHT = 240;
        const COLS = SCREEN_WIDTH / TILE_SIZE;
        const ROWS = SCREEN_HEIGHT / TILE_SIZE;

        // --- ENUMS & TYPES ---
        const GameState = {
            TITLE: 'title',
            EXPLORE: 'explore',
            BATTLE: 'battle',
            MENU: 'menu',
            DIALOG: 'dialog'
        };

        const Direction = {
            UP: 0, DOWN: 1, LEFT: 2, RIGHT: 3
        };

        // --- ASSET MANAGER (Programmatic Drawing) ---
        class AssetManager {
            constructor() {
                this.tiles = {}; // Map of name to canvas
                this.generateTiles();
            }

            createTile(name, drawFn) {
                const offscreen = document.createElement('canvas');
                offscreen.width = TILE_SIZE;
                offscreen.height = TILE_SIZE;
                const oCtx = offscreen.getContext('2d');
                drawFn(oCtx);
                this.tiles[name] = offscreen;
            }

            generateTiles() {
                // Grass
                this.createTile('grass', (c) => {
                    c.fillStyle = '#0a0';
                    c.fillRect(0, 0, 16, 16);
                    c.fillStyle = '#1b1';
                    c.fillRect(2, 2, 2, 2);
                    c.fillRect(10, 8, 2, 2);
                });
                // Sea
                this.createTile('sea', (c) => {
                    c.fillStyle = '#00f';
                    c.fillRect(0, 0, 16, 16);
                    c.strokeStyle = '#fff';
                    c.beginPath(); c.moveTo(2, 4); c.lineTo(6, 4); c.stroke();
                    c.beginPath(); c.moveTo(10, 12); c.lineTo(14, 12); c.stroke();
                });
                // Wall
                this.createTile('wall', (c) => {
                    c.fillStyle = '#888';
                    c.fillRect(0, 0, 16, 16);
                    c.strokeStyle = '#fff';
                    c.strokeRect(1, 1, 14, 14);
                });
                // Floor
                this.createTile('floor', (c) => {
                    c.fillStyle = '#ccc';
                    c.fillRect(0, 0, 16, 16);
                    c.strokeStyle = '#999';
                    c.strokeRect(0, 0, 16, 16);
                });
                // Mountain
                this.createTile('mountain', (c) => {
                    c.fillStyle = '#863';
                    c.fillRect(0, 0, 16, 16);
                    c.fillStyle = '#fff';
                    c.beginPath(); c.moveTo(8, 2); c.lineTo(14, 14); c.lineTo(2, 14); c.close(); c.fill();
                });
                // Town/Castle entrance
                this.createTile('town', (c) => {
                    c.fillStyle = '#0a0'; c.fillRect(0, 0, 16, 16);
                    c.fillStyle = '#c60'; c.fillRect(3, 3, 10, 10);
                    c.fillStyle = '#fc0'; c.fillRect(5, 5, 6, 6);
                    c.fillStyle = '#c60'; c.fillRect(7, 2, 2, 3);
                });
                // Player sprites (4 directions) - DQ2 hero style
                this.createTile('player_down', (c) => {
                    c.fillStyle = '#6060ff'; c.fillRect(4, 0, 8, 4); // helmet
                    c.fillStyle = '#fcc'; c.fillRect(4, 4, 8, 4); // face
                    c.fillStyle = '#00c'; c.fillRect(3, 8, 10, 5); // body
                    c.fillStyle = '#c60'; c.fillRect(4, 13, 3, 3); c.fillRect(9, 13, 3, 3); // boots
                });
                this.createTile('player_up', (c) => {
                    c.fillStyle = '#6060ff'; c.fillRect(4, 0, 8, 4);
                    c.fillStyle = '#60f'; c.fillRect(4, 4, 8, 4);
                    c.fillStyle = '#00c'; c.fillRect(3, 8, 10, 5);
                    c.fillStyle = '#c60'; c.fillRect(4, 13, 3, 3); c.fillRect(9, 13, 3, 3);
                });
                this.createTile('player_left', (c) => {
                    c.fillStyle = '#6060ff'; c.fillRect(3, 0, 8, 4);
                    c.fillStyle = '#fcc'; c.fillRect(3, 4, 6, 4);
                    c.fillStyle = '#00c'; c.fillRect(3, 8, 9, 5);
                    c.fillStyle = '#c60'; c.fillRect(3, 13, 3, 3); c.fillRect(8, 13, 3, 3);
                });
                this.createTile('player_right', (c) => {
                    c.fillStyle = '#6060ff'; c.fillRect(5, 0, 8, 4);
                    c.fillStyle = '#fcc'; c.fillRect(7, 4, 6, 4);
                    c.fillStyle = '#00c'; c.fillRect(4, 8, 9, 5);
                    c.fillStyle = '#c60'; c.fillRect(5, 13, 3, 3); c.fillRect(10, 13, 3, 3);
                });
            }
        }

        const assets = new AssetManager();

        // --- MAP SYSTEM ---
        const MapType = {
            GRASS: 'grass',
            SEA: 'sea',
            WALL: 'wall',
            FLOOR: 'floor',
            MOUNTAIN: 'mountain'
        };

        // Generate a 32x32 world map procedurally
        function generateWorldMap() {
            const W = 32, H = 32;
            const map = [];
            for (let y = 0; y < H; y++) {
                const row = [];
                for (let x = 0; x < W; x++) {
                    // Border = sea
                    if (x === 0 || y === 0 || x === W-1 || y === H-1) { row.push(1); continue; }
                    // Second border ring = sea (island feel)
                    if (x === 1 || y === 1 || x === W-2 || y === H-2) { row.push(1); continue; }
                    row.push(0); // grass by default
                }
                map.push(row);
            }
            // Mountains
            [[4,4],[4,5],[5,4],[5,5],[14,3],[15,3],[14,4],[20,20],[21,20],[20,21]].forEach(([x,y]) => map[y][x] = 4);
            // Castle (ローレシア城 placeholder) - walls + floor
            for (let y = 8; y <= 12; y++) for (let x = 8; x <= 12; x++) {
                if (y === 8 || y === 12 || x === 8 || x === 12) map[y][x] = 2; // wall
                else map[y][x] = 3; // floor
            }
            map[12][10] = 0; // castle entrance
            // Town
            map[6][20] = 5;
            // Another town
            map[22][8] = 5;
            // Lakes
            [[18,10],[19,10],[18,11],[19,11],[25,15],[26,15],[25,16]].forEach(([x,y]) => map[y][x] = 1);
            // Forest patches (use grass with slight variation - still grass tile for now)
            // More mountains for variety
            [[24,5],[25,5],[24,6],[10,22],[11,22],[10,23],[28,25],[29,25],[28,26]].forEach(([x,y]) => map[y][x] = 4);
            return map;
        }
        const WORLD_MAP = generateWorldMap();

        const TILE_MAP = [MapType.GRASS, MapType.SEA, MapType.WALL, MapType.FLOOR, MapType.MOUNTAIN, 'town'];

        // Passability: true = can walk on
        const TILE_PASSABLE = { grass: true, sea: false, wall: false, floor: true, mountain: false, town: true };

        // Encounter rate per tile type (0 = no encounters)
        // FC DQ2: ~1/16 to 1/24 chance per step on grass
        const TILE_ENCOUNTER_RATE = { grass: 12, sea: 0, wall: 0, floor: 0, mountain: 0, town: 0 };

        // ===== DATA: MONSTERS (placeholder for Phase 2) =====
        const MONSTERS = [
            { id: 0, name: 'スライム', hp: 5, mp: 0, atk: 6, def: 2, agi: 3, exp: 1, gold: 1 },
            { id: 1, name: 'おおなめくじ', hp: 8, mp: 0, atk: 9, def: 3, agi: 1, exp: 2, gold: 3 },
            { id: 2, name: 'ドラキー', hp: 6, mp: 0, atk: 8, def: 4, agi: 6, exp: 2, gold: 2 },
        ];

        // ===== DATA: PARTY GROWTH TABLES (FC DQ2 approximate) =====
        // [lv] = { hp, mp, str, agi, exp_to_next }
        const GROWTH = {
            lorasia: [
                null, // lv0 unused
                { hp:15, mp:0,  str:8,  agi:4,  def:4,  exp:0 },
                { hp:22, mp:0,  str:12, agi:5,  def:6,  exp:7 },
                { hp:28, mp:0,  str:16, agi:7,  def:8,  exp:23 },
                { hp:36, mp:0,  str:22, agi:8,  def:11, exp:47 },
                { hp:42, mp:0,  str:28, agi:10, def:14, exp:110 },
                { hp:52, mp:0,  str:34, agi:12, def:17, exp:220 },
                { hp:60, mp:0,  str:40, agi:14, def:20, exp:450 },
                { hp:70, mp:0,  str:48, agi:16, def:24, exp:800 },
                { hp:82, mp:0,  str:56, agi:18, def:28, exp:1300 },
                { hp:95, mp:0,  str:64, agi:20, def:32, exp:2000 },
            ],
            samaltria: [
                null,
                { hp:10, mp:5,  str:4,  agi:3,  def:3,  exp:0 },
                { hp:16, mp:8,  str:7,  agi:5,  def:5,  exp:12 },
                { hp:22, mp:12, str:10, agi:7,  def:7,  exp:35 },
                { hp:28, mp:18, str:14, agi:9,  def:9,  exp:65 },
                { hp:34, mp:24, str:18, agi:12, def:12, exp:140 },
                { hp:42, mp:32, str:22, agi:14, def:14, exp:280 },
                { hp:50, mp:40, str:26, agi:17, def:17, exp:560 },
                { hp:58, mp:50, str:30, agi:20, def:20, exp:1000 },
                { hp:66, mp:60, str:36, agi:23, def:23, exp:1600 },
                { hp:76, mp:72, str:42, agi:26, def:26, exp:2500 },
            ],
            moonbrook: [
                null,
                { hp:8,  mp:8,  str:3,  agi:6,  def:2,  exp:0 },
                { hp:12, mp:14, str:5,  agi:8,  def:4,  exp:10 },
                { hp:16, mp:22, str:7,  agi:11, def:5,  exp:30 },
                { hp:20, mp:30, str:9,  agi:14, def:7,  exp:55 },
                { hp:26, mp:40, str:11, agi:18, def:9,  exp:120 },
                { hp:32, mp:52, str:14, agi:22, def:11, exp:250 },
                { hp:38, mp:64, str:16, agi:26, def:14, exp:500 },
                { hp:44, mp:78, str:19, agi:30, def:16, exp:900 },
                { hp:52, mp:92, str:22, agi:34, def:19, exp:1500 },
                { hp:60, mp:108,str:26, agi:38, def:22, exp:2300 },
            ],
        };

        // Create a party member from growth table at a given level
        function createPartyMember(name, classKey, level) {
            const g = GROWTH[classKey][level];
            return {
                name, classKey, level,
                maxHp: g.hp, hp: g.hp,
                maxMp: g.mp, mp: g.mp,
                str: g.str, agi: g.agi, def: g.def,
                exp: 0, gold: 0,
                equipment: { weapon: null, armor: null, shield: null, helmet: null },
                alive: true,
            };
        }

        // Direction sprite names
        const DIR_SPRITES = ['player_up', 'player_down', 'player_left', 'player_right'];

        // --- CORE ENGINE ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        // ===== ENGINE: STATE/LOOP/INPUT =====
        class GameEngine {
            constructor() {
                this.state = GameState.TITLE;
                this.lastTime = 0;
                this.keys = {};
                this.keyPressed = {}; // single-press detection
                this.player = { x: 10, y: 14, dir: Direction.DOWN }; // start near castle entrance
                this.camera = { x: 0, y: 0 }; // top-left tile of viewport
                this.moveTimer = 0;
                this.MOVE_DELAY = 150; // ms between steps (FC DQ2 feel)
                this.titleBlink = 0;
                this.message = null; // { text, callback }
                this.battle = null; // battle state object
                // Party initialization (start with hero only, others join later)
                this.party = [
                    createPartyMember('ローレシア', 'lorasia', 1),
                ];
                this.gold = 0;
                this.updateCamera();
                this.initInputs();
            }

            initInputs() {
                window.addEventListener('keydown', (e) => {
                    e.preventDefault();
                    if (!this.keys[e.code]) this.keyPressed[e.code] = true;
                    this.keys[e.code] = true;
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                    this.keyPressed[e.code] = false;
                });
            }

            consumeKey(code) {
                if (this.keyPressed[code]) { this.keyPressed[code] = false; return true; }
                return false;
            }

            start() {
                this.lastTime = performance.now();
                requestAnimationFrame((t) => this.loop(t));
            }

            loop(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(dt);
                this.draw();
                requestAnimationFrame((t) => this.loop(t));
            }

            // --- UPDATE ---
            update(dt) {
                if (this.state === GameState.TITLE) {
                    this.titleBlink += dt;
                    if (this.consumeKey('Enter') || this.consumeKey('KeyZ')) {
                        this.state = GameState.EXPLORE;
                    }
                } else if (this.state === GameState.EXPLORE) {
                    this.updateMovement(dt);
                } else if (this.state === GameState.DIALOG) {
                    if (this.consumeKey('Enter') || this.consumeKey('KeyZ')) {
                        if (this.message && this.message.callback) this.message.callback();
                        this.message = null;
                        this.state = GameState.EXPLORE;
                    }
                } else if (this.state === GameState.BATTLE) {
                    this.updateBattle(dt);
                }
            }

            updateMovement(dt) {
                this.moveTimer -= dt;
                if (this.moveTimer > 0) return;

                let dx = 0, dy = 0, newDir = this.player.dir;
                if (this.keys['ArrowUp'])    { dy = -1; newDir = Direction.UP; }
                else if (this.keys['ArrowDown'])  { dy = 1;  newDir = Direction.DOWN; }
                else if (this.keys['ArrowLeft'])  { dx = -1; newDir = Direction.LEFT; }
                else if (this.keys['ArrowRight']) { dx = 1;  newDir = Direction.RIGHT; }

                if (dx === 0 && dy === 0) return;

                this.player.dir = newDir;
                const nx = this.player.x + dx;
                const ny = this.player.y + dy;

                // Bounds check
                if (ny < 0 || ny >= WORLD_MAP.length || nx < 0 || nx >= WORLD_MAP[0].length) {
                    this.moveTimer = this.MOVE_DELAY;
                    return;
                }

                // Collision check
                const tileId = WORLD_MAP[ny][nx];
                const tileName = TILE_MAP[tileId];
                if (!TILE_PASSABLE[tileName]) {
                    this.moveTimer = this.MOVE_DELAY;
                    return;
                }

                this.player.x = nx;
                this.player.y = ny;
                this.moveTimer = this.MOVE_DELAY;
                this.updateCamera();

                // Encounter check
                this.checkEncounter(tileName);
            }

            checkEncounter(tileName) {
                const rate = TILE_ENCOUNTER_RATE[tileName] || 0;
                if (rate <= 0) return;
                // 1/rate chance per step
                if (Math.floor(Math.random() * rate) === 0) {
                    this.startBattle();
                }
            }

            startBattle() {
                // Pick random monster group (1-3 enemies for now)
                const count = 1 + Math.floor(Math.random() * 2);
                this.battle = {
                    enemies: [],
                    phase: 'start', // start -> command -> execute -> result -> end
                    cursor: 0,
                    turnLog: [],
                    resultTimer: 0,
                };
                for (let i = 0; i < count; i++) {
                    const template = MONSTERS[Math.floor(Math.random() * MONSTERS.length)];
                    this.battle.enemies.push({ ...template, currentHp: template.hp });
                }
                this.state = GameState.BATTLE;
            }

            updateCamera() {
                const mapW = WORLD_MAP[0].length;
                const mapH = WORLD_MAP.length;
                // Center camera on player
                this.camera.x = this.player.x - Math.floor(COLS / 2);
                this.camera.y = this.player.y - Math.floor(ROWS / 2);
                // Clamp to map bounds
                this.camera.x = Math.max(0, Math.min(this.camera.x, mapW - COLS));
                this.camera.y = Math.max(0, Math.min(this.camera.y, mapH - ROWS));
            }

            showMessage(text, callback) {
                this.message = { text, callback: callback || null };
                this.state = GameState.DIALOG;
            }

            // --- BATTLE UPDATE ---
            updateBattle(dt) {
                const b = this.battle;
                if (b.phase === 'start') {
                    // Show encounter message briefly
                    b.resultTimer += dt;
                    if (b.resultTimer > 800) {
                        b.phase = 'command';
                        b.cursor = 0;
                        b.resultTimer = 0;
                    }
                } else if (b.phase === 'command') {
                    // Player selects: たたかう(0) / にげる(1)
                    if (this.consumeKey('ArrowUp') || this.consumeKey('ArrowDown')) {
                        b.cursor = b.cursor === 0 ? 1 : 0;
                    }
                    if (this.consumeKey('Enter') || this.consumeKey('KeyZ')) {
                        if (b.cursor === 1) {
                            // にげる - FC DQ2: ~50% chance to flee
                            if (Math.random() < 0.5) {
                                b.turnLog = ['うまく にげきれた！'];
                                b.phase = 'end';
                            } else {
                                b.turnLog = ['しかし まわりこまれてしまった！'];
                                b.phase = 'enemy_turn';
                            }
                        } else {
                            // たたかう - simple attack
                            b.turnLog = [];
                            this.executeBattleTurn();
                        }
                        b.resultTimer = 0;
                    }
                } else if (b.phase === 'player_result' || b.phase === 'enemy_turn') {
                    b.resultTimer += dt;
                    if (b.resultTimer > 1200 || this.consumeKey('Enter') || this.consumeKey('KeyZ')) {
                        b.resultTimer = 0;
                        if (b.phase === 'player_result') {
                            if (b.enemies.every(e => e.currentHp <= 0)) {
                                const totalExp = b.enemies.reduce((s, e) => s + e.exp, 0);
                                const totalGold = b.enemies.reduce((s, e) => s + e.gold, 0);
                                this.gold += totalGold;
                                b.turnLog = [`まものを たおした！`, `${totalExp}の けいけんちを かくとく！`, `${totalGold}ゴールド てにいれた！`];
                                // Award EXP and check level up
                                this.party.filter(p => p.alive).forEach(p => {
                                    p.exp += totalExp;
                                    const lvUp = this.checkLevelUp(p);
                                    if (lvUp) b.turnLog.push(`${p.name}は レベル${p.level}に あがった！`);
                                });
                                b.phase = 'end';
                            } else {
                                b.phase = 'enemy_turn';
                                this.executeEnemyTurn();
                            }
                        } else {
                            // After enemy turn, check party wipe
                            if (this.party.every(p => !p.alive)) {
                                b.turnLog = ['ぜんめつしてしまった…'];
                                b.phase = 'gameover';
                            } else {
                                b.phase = 'command';
                                b.cursor = 0;
                            }
                        }
                    }
                } else if (b.phase === 'gameover') {
                    b.resultTimer += dt;
                    if (b.resultTimer > 2000 || this.consumeKey('Enter') || this.consumeKey('KeyZ')) {
                        // Revive at start, lose half gold (FC DQ2 style)
                        this.gold = Math.floor(this.gold / 2);
                        this.party.forEach(p => {
                            p.hp = p.maxHp; p.mp = p.maxMp; p.alive = true;
                        });
                        this.player.x = 10; this.player.y = 14; // Castle position
                        this.updateCamera();
                        this.state = GameState.EXPLORE;
                        this.battle = null;
                    }
                } else if (b.phase === 'end') {
                    b.resultTimer += dt;
                    if (b.resultTimer > 1500 || this.consumeKey('Enter') || this.consumeKey('KeyZ')) {
                        this.state = GameState.EXPLORE;
                        this.battle = null;
                    }
                }
            }

            checkLevelUp(member) {
                const growth = GROWTH[member.classKey];
                const nextLv = member.level + 1;
                if (nextLv >= growth.length) return false;
                const needed = growth[nextLv].exp;
                if (member.exp >= needed) {
                    member.level = nextLv;
                    const g = growth[nextLv];
                    member.maxHp = g.hp; member.hp = g.hp; // Full heal on level up (FC DQ2)
                    member.maxMp = g.mp; member.mp = g.mp;
                    member.str = g.str; member.agi = g.agi; member.def = g.def;
                    member.exp = 0; // Reset exp (simplified; FC uses cumulative)
                    return true;
                }
                return false;
            }

            // FC DQ2 damage formula: dmg = atk/2 - def/4 + rand(-1..+2)
            calcDamage(atk, def) {
                const base = Math.floor(atk / 2) - Math.floor(def / 4);
                const dmg = base + Math.floor(Math.random() * 4) - 1;
                return Math.max(0, dmg);
            }

            executeBattleTurn() {
                const b = this.battle;
                const hero = this.party[0];
                const target = b.enemies.find(e => e.currentHp > 0);
                if (!target || !hero.alive) return;
                const dmg = this.calcDamage(hero.str, target.def);
                target.currentHp = Math.max(0, target.currentHp - dmg);
                b.turnLog = [`${hero.name}の こうげき！`];
                if (dmg > 0) {
                    b.turnLog.push(`${target.name}に ${dmg}の ダメージ！`);
                } else {
                    b.turnLog.push(`ミス！ ダメージを あたえられない！`);
                }
                if (target.currentHp <= 0) {
                    b.turnLog.push(`${target.name}を たおした！`);
                }
                b.phase = 'player_result';
                b.resultTimer = 0;
            }

            executeEnemyTurn() {
                const b = this.battle;
                const alive = b.enemies.filter(e => e.currentHp > 0);
                if (alive.length === 0) return;
                const attacker = alive[Math.floor(Math.random() * alive.length)];
                // Target random alive party member
                const targets = this.party.filter(p => p.alive);
                if (targets.length === 0) return;
                const target = targets[Math.floor(Math.random() * targets.length)];
                const dmg = this.calcDamage(attacker.atk, target.def);
                target.hp = Math.max(0, target.hp - dmg);
                b.turnLog = [`${attacker.name}の こうげき！`];
                if (dmg > 0) {
                    b.turnLog.push(`${target.name}は ${dmg}の ダメージをうけた！`);
                } else {
                    b.turnLog.push(`${target.name}は ダメージをうけなかった！`);
                }
                if (target.hp <= 0) {
                    target.alive = false;
                    b.turnLog.push(`${target.name}は ちからつきた！`);
                }
            }

            // --- DRAW ---
            draw() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                if (this.state === GameState.TITLE) {
                    this.drawTitle();
                } else if (this.state === GameState.EXPLORE || this.state === GameState.DIALOG || this.state === GameState.MENU) {
                    this.drawMap();
                    this.drawPlayer();
                    this.drawFieldStatus();
                    if (this.state === GameState.DIALOG && this.message) {
                        this.drawMessageWindow(this.message.text);
                    }
                } else if (this.state === GameState.BATTLE) {
                    this.drawBattle();
                }
            }

            drawBattle() {
                const b = this.battle;
                // Black background
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);

                // Enemy area (top half)
                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                // Draw enemies
                const alive = b.enemies.filter(e => e.currentHp > 0);
                alive.forEach((enemy, i) => {
                    const ex = 80 + i * 50, ey = 30;
                    // Simple enemy sprite (colored rectangle)
                    ctx.fillStyle = '#0c0';
                    ctx.fillRect(ex, ey, 24, 24);
                    ctx.fillStyle = '#080';
                    ctx.fillRect(ex + 4, ey + 4, 16, 16);
                    // Enemy name below
                    ctx.fillStyle = '#fff';
                    ctx.font = '7px monospace';
                    ctx.fillText(enemy.name, ex - 8, ey + 28);
                });

                // Encounter message or turn log
                const logY = 80;
                this.drawWindow(8, logY, SCREEN_WIDTH - 16, 50);
                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                if (b.phase === 'start') {
                    const names = [...new Set(b.enemies.map(e => e.name))];
                    ctx.fillText(`${names.join('と ')}が あらわれた！`, 16, logY + 8);
                } else if (b.turnLog.length > 0) {
                    b.turnLog.forEach((line, i) => {
                        ctx.fillText(line, 16, logY + 8 + i * 12);
                    });
                }

                // Party status window (right side, FC DQ2 style)
                const stX = 140, stY = 148, stW = 110, stH = 12 + this.party.length * 14;
                this.drawWindow(stX, stY, stW, stH);
                ctx.fillStyle = '#fff';
                ctx.font = '7px monospace';
                this.party.forEach((p, i) => {
                    const shortName = p.name.substring(0, 4);
                    const hpStr = `${String(p.hp).padStart(3)}/${String(p.maxHp).padStart(3)}`;
                    const mpStr = p.maxMp > 0 ? ` M${String(p.mp).padStart(2)}` : '';
                    const status = p.alive ? '' : ' しに';
                    ctx.fillText(`${shortName} H${hpStr}${mpStr}${status}`, stX + 6, stY + 8 + i * 14);
                });

                // Command window (only during command phase)
                if (b.phase === 'command') {
                    const cmdX = 8, cmdY = 150, cmdW = 100, cmdH = 40;
                    this.drawWindow(cmdX, cmdY, cmdW, cmdH);
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px monospace';
                    const cmds = ['たたかう', 'にげる'];
                    cmds.forEach((cmd, i) => {
                        const prefix = b.cursor === i ? '▶' : '　';
                        ctx.fillText(`${prefix}${cmd}`, cmdX + 8, cmdY + 8 + i * 14);
                    });
                }

                // Gameover overlay
                if (b.phase === 'gameover') {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText('おうは しんでしまった！', SCREEN_WIDTH / 2, 220);
                    ctx.textAlign = 'left';
                }
            }

            drawTitle() {
                // FC DQ2 style: black bg, centered text
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Title
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px monospace';
                ctx.fillText('ドラゴンクエストII', SCREEN_WIDTH / 2, 80);
                ctx.font = '10px monospace';
                ctx.fillText('悪霊の神々', SCREEN_WIDTH / 2, 100);

                // Blinking "press start"
                if (Math.floor(this.titleBlink / 500) % 2 === 0) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '8px monospace';
                    ctx.fillText('ぼうけんをはじめる（Enter）', SCREEN_WIDTH / 2, 170);
                }

                ctx.textAlign = 'left';
                ctx.textBaseline = 'alphabetic';
            }

            drawMap() {
                const cx = this.camera.x, cy = this.camera.y;
                for (let sy = 0; sy < ROWS; sy++) {
                    for (let sx = 0; sx < COLS; sx++) {
                        const mx = cx + sx, my = cy + sy;
                        if (my < 0 || my >= WORLD_MAP.length || mx < 0 || mx >= WORLD_MAP[0].length) continue;
                        const tileId = WORLD_MAP[my][mx];
                        const tileName = TILE_MAP[tileId];
                        if (assets.tiles[tileName]) {
                            ctx.drawImage(assets.tiles[tileName], sx * TILE_SIZE, sy * TILE_SIZE);
                        }
                    }
                }
            }

            drawPlayer() {
                const sprite = DIR_SPRITES[this.player.dir];
                const sx = (this.player.x - this.camera.x) * TILE_SIZE;
                const sy = (this.player.y - this.camera.y) * TILE_SIZE;
                ctx.drawImage(assets.tiles[sprite], sx, sy);
            }

            drawFieldStatus() {
                // Small status bar at top-right (FC DQ2 style)
                const sw = 90, sh = 12 + this.party.length * 12;
                const sx = SCREEN_WIDTH - sw - 4, sy = 4;
                this.drawWindow(sx, sy, sw, sh);
                ctx.fillStyle = '#fff';
                ctx.font = '7px monospace';
                this.party.forEach((p, i) => {
                    const name = p.name.substring(0, 3);
                    ctx.fillText(`${name} L${p.level} H${p.hp}/${p.maxHp}`, sx + 5, sy + 7 + i * 12);
                });
            }

            // FC-style bordered window drawn on Canvas
            drawWindow(x, y, w, h) {
                // Outer border (white)
                ctx.fillStyle = '#fff';
                ctx.fillRect(x, y, w, h);
                // Inner fill (black)
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 2, y + 2, w - 4, h - 4);
                // Inner border highlight
                ctx.fillStyle = '#fff';
                ctx.fillRect(x + 1, y + 1, w - 2, 1);
                ctx.fillRect(x + 1, y + 1, 1, h - 2);
                ctx.fillRect(x + 1, y + h - 2, w - 2, 1);
                ctx.fillRect(x + w - 2, y + 1, 1, h - 2);
                // Black interior
                ctx.fillStyle = '#000';
                ctx.fillRect(x + 3, y + 3, w - 6, h - 6);
            }

            drawMessageWindow(text) {
                const wx = 8, wy = SCREEN_HEIGHT - 56, ww = SCREEN_WIDTH - 16, wh = 48;
                this.drawWindow(wx, wy, ww, wh);
                ctx.fillStyle = '#fff';
                ctx.font = '8px monospace';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                // Word wrap simple
                const maxChars = 28;
                const lines = [];
                for (let i = 0; i < text.length; i += maxChars) {
                    lines.push(text.substring(i, i + maxChars));
                }
                lines.forEach((line, idx) => {
                    ctx.fillText(line, wx + 8, wy + 8 + idx * 12);
                });
            }
        }

        const engine = new GameEngine();
        engine.start();

        // --- EXPORT FOR APPEND ---
        // Placeholder for future logic
    </script>
</body>

</html>